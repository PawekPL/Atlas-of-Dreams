
public BIOME_LIST  // get a list of biomes and their properties (most likely from csv/json file)
public KDTree biomeTree = KDTree(BIOME_LIST)  // get a K-dimensional tree from the biome list (in python this is done with the scipy library)
public dict assetDict  // get a list of paths to assets such as trees and buildings based on the selected biome
public dict settings // read settings from file 

class Vertex
	public int x
	public int y
	public int z
	private float humidity
	private float temperature
	private float erosion
	private float fantasyness
	private float evilness
	public string biome
	public string type		//there will be 3 vertex types: 
							//t - terrain vertex, the main vertex that dictates the shape of the terrain;
							//w - water vertex, vertex used for generating the surface of water
							//a - asset vertex, vertex containing information about asset placement
							//e - edge vertex, vertex for edge triangles  


	public procedure new(_x,_y,_z,type,[_humidity,_temperature,_erosion,_fantasyness,_evilness,_assetID])
		x = _x
		y = _y
		z = _z
		if type = "t"
			humidity = _humidity
			temperature = _temperature
			erosion = _erosion
			fantasyness = _fantasyness
			evilness = _evilness		
			biome = getBiome(y,humidity,temperature,erosion,fantasyness,evilness)
			y = calculateHeight(y,erosion)
		elseif type = "w"
			pass
		elseif type = "a"
			assetID = _assetID
		elseif type = "e"
			y = calculateHeight(y,erosion)
		endif
	endprocedure

	private function getBiome(y,humidity,temperature,erosion,fantasyness,evilness)
		private float dist
		private int id
		dist, id = biomeTree.query([y,humidity,temperature,erosion,fantasyness,evilness])  // find the closest vector to the vector from generated values
		return id
	endfunction

	private function calculateHeight(y,erosion)
		// Height will depend on the vertical scale, that will be implemented during evaluation.
		private float height
		height = 1 + (y+erosion/10) * 60    // the expression "y+erosion/10" might change later. I'll have to experiment on how that affects the heightmap. 60 will be the default height
		return height 
	endfunction
endclass

class Chunk
	private int size
	private int scale
	public array vertices //array to store all terrain vertices
	public dict assetsVert //dictionary to store all asset vertices
	public dict waterVert //dictionary to store all water vertices
	public dict edgeVert //dictionary to store all edge vertices
	public int chunkX
	public int chunkZ
	


	public procedure new(noise,noise_hu,noise_te,noise_er,noise_fa,noise_ev,chunkX,chunkZ) // pass trough the noise functions to get correct noise generation 
		size = settings["chunk-size"]
		scale = settings["vertex-scale"] // scale 2 will be the default (1 vertex square = 1 m^2)
		vertices[size,size]  // chunks have to be squares, size will be an integer, this sets the size of the array 
		for x in range(size)
			for z in range(size)
				vertices[x][z] =  Vertex(x*scale,noise(x*scale,z*scale),z*scale,"t",noise_hu(x*scale,z*scale),noise_te(x*scale,z*scale),noise_er(x*scale,z*scale),noise_fa(x*scale,z*scale),noise_ev(x*scale,z*scale)) 
				

				//Edge vertex generation
				if x == 0
					edgeVert[str((x-1,z))] = Vertex((x-1)*scale,noise((x-1)*scale,z*scale),z*scale,"e",erosion = noise_er((x-1)*scale,z*scale))  
				elseif x == size-1
					edgeVert[str((x+1,z))] = Vertex((x+1)*scale,noise((x+1)*scale,z*scale),z*scale,"e",erosion = noise_er((x+1)*scale,z*scale))
				endif
				if z == 0
					edgeVert[str((x,z-1))] = Vertex(x*scale,noise(x*scale,(z-1)*scale),(z-1)*scale,"e",erosion = noise_er(x*scale,(z-1)*scale))  
				elseif z == size-1
					edgeVert[str((x,z+1))] = Vertex(x*scale,noise(x*scale,(z+1)*scale),(z+1)*scale,"e",erosion = noise_er(x*scale,(z+1)*scale))
				endif


				//TODO: Write water generation
				
				// Check if a water vertex exists above the terrain vertex
				try 
					if waterVert[str((x,z)] //if it does, continue
						pass
					endif
				catch   // if it doesn't it will give KeyError
					//Generate assets
					biome = vertices.biome
					if biome == "forrest"
						//TODO: write a tree generator
					else
						assets = BIOME_LIST[biome]["Assets"]
						chosen_asset = assets.random()  // get id of a random asset assigned to the biome
						chance = 1 div int(BIOME_LIST[biome]["AssetChance"]) //chance that the asset spawns
						if randomint(0,chance) == 0  // get the random integer to decide if the asset spawns
							assetsVert[str((x,z)] = Vertex(x,vertices[x][z].y,z,"a",_assetID = assetID)
						endif
					endif
				endtry
			endfor
		endfor
		
	endprocedure

	public procedure genOBJ()
		private list tris
		private dict normals
		private list waterTris
		private dict waterNormals

		private str wavefront_tris
		private str wavefront_normals = ""

		private string name = str((chunkX,chunkZ)) // for chunk 0,0 the name will be "(0,0)" 

		private string wavefront = "mtllib biome-colour-map.mtl\no " + name +"\n"
		private string wavefrontWater
	

		for x in size
			for z in size
				wavefront += "v " + str(float(vertices[x][z].x)) + " " + str(float(vertices[x][z].z)) + " " + str(float(vertices[x][z].y)) + "\n"
				if x > 0 and z > 0
					tris.append(((x-1,z-1,vertices[x-1][z-1]),(x-1,z,vertices[x-1][z]),(x,z,vertices[x][z]))) 
				endif
				if x < size-1 and z < size-1 
					tris.append(((x,z,vertices[x][z]),(x+1,z+1,vertices[x+1][z+1]),(x+1,z,vertices[x+1][z])))
				endif
			endfor
		endfor

		for triangle in tris
			p1[3] = verts[triangle[0]][0] , verts[triangle[0]][2] , verts[triangle[0]][1]  // get values from a tuple and put them into the array
			p2[3] = verts[triangle[1]][0] , verts[triangle[1]][2] , verts[triangle[1]][1] 
			p3[3] = verts[triangle[2]][0] , verts[triangle[2]][2] , verts[triangle[2]][1] 
	
			normals[triangle.index] = crossproduct(p2-p1,p3-p1) // use a crossproduct to calculate the normal vertex
	
			wavefront_normals += "vn "+str(normals[triangle.index][0])+" "+str(normals[triangle.index][1])+" "+str(normals[triangle.index][2])+ "\n"
			wavefront_tris += "f "+str(triangle[0]+1)+"//"+str(triangle.index+1)+" "+str(triangle[1]+1)+"//"+str(triangle.index+1)+" "+str(triangle[2]+1)+"//"+str(triangle.index+1)+"\n"
	
		wavefront += wavefront_normals
		wavefront += "usemtl Default\ns off\n"
		wavefront += wavefront_tris
		


		name += ".obj"
	
		file = open(chname,"write") // open obj file in the write mode
		file.write(wavefront)
		file.close()


	endprocedure


endclass

public function loadAsset(path,offsetX,offsetY,offsetZ,offsetV,offsetVN)
	private string output
	private file file = open(path,"r")
	private string asset = file.read()
	private vertices = regex(asset,"v -?[0-9]\.[0-9]+ -?[0-9]\.[0-9]+ -?[0-9]\.[0-9]+","multiline") // get list of all vertices using regex 
	private replacement = "\n".join(vertices)
	for vertex in vertices
		value = vertex.split(" ")
		value[1] = int(value[1])+offsetX
		value[2] = int(value[2])+offsetZ
		value[3] = int(value[3])+offsetY
		vertices[vertex.index] = "v "+ " ".join(value)
	asset.replace(replacement,"\n".join(vertices))
	private faces = regex(asset,"f( [0-9]+\/[0-9]*\/[0-9]){3,4}","multiline") // get list of all faces using regex 
	private replacement = "\n".join(faces)
	for f in faces // example: f = "f 1/1/1 5/2/1 7/3/1 3/4/1"
		g = f.split(" ") // g = ["f","1/1/1","5/2/1","7/3/1","3/4/1"]
		for vertex in g:
			if vertex == "f"
				pass
			endif
			values = vertex.split("/") //values = ["1","1","1"]
			values[0] = str(int(values[0])+offsetV)
			values[2] = str(int(values[2])+offsetVN) 
			g[vertex.index] = "/".join(values)
		faces[f.index] = " ".join(g)
		endfor		
	endfor
	asset.replace(replacement,"\n".join(faces)) 
	return asset
endfunction


// TODO:
// When converting to obj use triangle formed with other chunks
// **Generate assets using the grid (OpenSimplex accepts floats)


//NOTES:
// DON'T EXPORT CHUNKS