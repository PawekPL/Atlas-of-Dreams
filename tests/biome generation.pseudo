
public BIOME_LIST  // get a list of biomes and their properties (most likely from csv/json file)
public KDTree biomeTree = KDTree(BIOME_LIST)  // get a K-dimensional tree from the biome list (in python this is done with the scipy library)
public dict assetDict  // get a list of paths to assets such as trees and buildings based on the selected biome
public dict settings // read settings from file 

class Vertex
	public int x
	public int y
	public int z
	private float humidity
	private float temperature
	private float erosion
	private float fantasyness
	private float evilness
	public string biome
	public string type		//there will be 3 vertex types: 
							//t - terrain vertex, the main vertex that dictates the shape of the terrain;
							//w - water vertex, vertex used for generating the surface of water
							//a - asset vertex, vertex containing information about asset placement
							//e - edge vertex, vertex for edge triangles  


	public procedure new(_x,_y,_z,type,[_humidity,_temperature,_erosion,_fantasyness,_evilness,_assetID])
		x = _x
		y = _y
		z = _z
		if type = "t"
			humidity = _humidity
			temperature = _temperature
			erosion = _erosion
			fantasyness = _fantasyness
			evilness = _evilness		
			biome = getBiome(y,humidity,temperature,erosion,fantasyness,evilness)
			y = calculateHeight(y,erosion)
		else if type = "w"
			pass
		else if type = "a"
			assetID = _assetID
		else if type = "e"
		endif
	endprocedure

	private function getBiome(y,humidity,temperature,erosion,fantasyness,evilness)
		private float dist
		private int id
		dist, id = biomeTree.query([y,humidity,temperature,erosion,fantasyness,evilness])  // find the closest vector to the vector from generated values
		return id
	endfunction

	private function calculateHeight(y,erosion)
		// Height will depend on the vertical scale, that will be implemented during evaluation.
		private float height
		height = 1 + (y+erosion/10) * 60    // the expression "y+erosion/10" might change later. I'll have to experiment on how that affects the heightmap. 60 will be the default height
		return height 
	endfunction
endclass

class Chunk
	private int size
	private int scale
	public array vertices //array to store all terrain vertices
	public dict assetsVert //dictionary to store all asset vertices
	public dict waterVert //dictionary to store all water vertices
	public int chunkX
	public int chunkZ
	


	public procedure new(noise,noise_hu,noise_te,noise_er,noise_fa,noise_ev,chunkX,chunkZ) // pass trough the noise functions to get correct noise generation 
		size = settings["chunk-size"]
		scale = settings["vertex-scale"] // scale 2 will be the default (1 vertex square = 1 m^2)
		vertices[size,size]  // chunks have to be squares, size will be an integer, this sets the size of the array 
		for x in size
			for z in size
				vertices[x][z] =  Vertex(x*scale,noise(x*scale,z*scale),z*scale,"t",noise_hu(x*scale,z*scale),noise_te(x*scale,z*scale),noise_er(x*scale,z*scale),noise_fa(x*scale,z*scale),noise_ev(x*scale,z*scale)) 
				//TODO: Write water generation

				// Check if a water vertex exists above the terrain vertex
				try 
					if waterVert[SIZE*x+z] //if it does, continue
						pass
					endif
				catch   // if it doesn't it will give KeyError
					//Generate assets
					biome = vertices.biome
					if biome == "forrest"
						//write tree generator
					else:
						assets = BIOME_LIST[biome]["Assets"]
						chosen_asset = assets.random()  // get id of the asset
						chance = 1 div int(BIOME_LIST[biome]["AssetChance"]) //chance that the asset spawns
						if randomint(0,chance) == 0  // get the random integer to decide if the asset spawns
							assetsVert[SIZE*x+z] = Vertex(x,vertices[x][z].y,z,"a",_assetID = assetID)
						endif
					endif
				endtry
			endfor
		endfor
		
	endprocedure


endclass



// TODO:
// When converting to obj use triangle formed with other chunks
// Generate assets using the grid (OpenSimplex accepts floats)
// Set the final scale

//NOTES:
// DON'T EXPORT CHUNKS